《java 编程思想》
第二章 一切皆是对象
    2.1 使用引用操作对象
        在java里，一切都被视为引用
        例如 想要操纵一个词或者句子 创建一个String 引用
            String s;
        这里的 s 是一个引用，而不是一个对象。如果向s发送一个消息，就会出错，因此需要 创建引用的时候就进行初始化
            String s = "string";（这里是一种特殊的初始化方法，但是应该使对象用一种更普遍的初始化方法）

    2.2 必须由你创建所有的对象
        一旦创建了一个引用，就希望创建一个新的对象与之关联。使用 关键字 new 创建一个新的对象
            String s = new String("string");

        2.2.1 数据存储
            寄存器、堆栈、栈、常量存储、非RAM存储

        2.2.2 基本类型
            基本类型  --- 包装类型          大小 bits
            boolean --- Boolean          true/false
            char    --- Character           16
            byte    --- Byte                8
            short   --- Short               16
            int     --- Integer             32
            long    --- Long                64
            float   --- Float               32
            double  --- Double              64
            void    --- Void
            所有的基本类型 具有 包装器类 可以在堆创建一个非基本对象 使用包装类型的原因后续说明
                char c = 'x';
                Character ch = new Character(c)
                Character ch = new Character('x')
                java se5 可以实现自动转换类型
    2.3 数组
        Java 创建数组的时候就是创建了一个引用数组，在使用任何的引用前，必须为其指定一个对象。当初始化的值为null 时，会报错

        2.3.1 作用域
            {
                int x = 12;
                {
                    int x =96;
                }
            }      // 在C++合法，但是在Java不合法 ，x 被定义了
            在C++中，变量的作用域决定了它的可见性和生存期。在你提供的代码中，两个 "x" 变量分别位于不同的作用域内，因此不会导致已经定义的错误。
            在内层作用域中定义一个与外层作用域相同名称的变量是合法的，这不会引发编译错误。在这种情况下，内层作用域中的变量将会隐藏外层作用域中的同名变量
            即在内层作用域内，使用 "x" 变量将引用内层作用域中的那个。
            在 Java 中，是不允许在一个作用域内定义与外部作用域相同名称的变量的
        2.3.2 对象的作用域
            Java 有一个垃圾回收器，当对象的引用不存在时，引用所指向的对象的内存空间就会被自动回收

    2.4 字段和方法
        1 Java 定义了一个类之后，就要设置两种元素 字段 和 方法
        2 基本类型的字段 作为类的成员使用 会自动初始化，但是 字段 是一个对象的引用时就必须初始化该引用
        3 局部变量 不会被自动初始化，必须手动初始化，否则会报错
        4 方法 必须通过 对象来调用 （static 关键字 不依赖对象）
        5 OOP 向对象发送消息
        6 import 用来导入包
    2.5 static 关键字
        1 当创建一个类时，执行 new 创建 引用对应的对象时才会分配空间，会出现两种情况：
            （1） 只想要未某一特定域分配空间，但是不考虑要创建多少对象
            （2） 在某个类不创建对象，我们也需要去调用这个类的方法
        2 使用 static 关键字解决上面两种情况
        3 static 字段可以通过对象来调用，也可以通过类来调用
        4 每一个static 字段 只有一份存储空间  非static 字段每个对象有一份存储空间
        5 每个Java 文件会自动导入 java.lang
    2.6 代码风格 与 注释

第三章 操作符
    1 移位操作符
        （1）只可以用来处理整数类型
        （2）对于有符号数，右移位操作时符号位为正，高位插入0，否则插入1. 左移在低位补零
        （3）>>>= 无符号数的右移，高位插入0
    2 类型转换
    3 截尾和舍入
        在把float 和 double 转换为int 时，截尾。如果需要舍入，使用Java.lang.math 的 round 方法
    4 Java 没有 sizeof 所有数据类型的大小是确定的

第四章 控制执行流程
    1 if -else
    2 while
    3 do -while
    4 for
    5 Foreach 语法
        float f[] = new float[10]
        for (float x : f)
    6 return
    7 break -- continue
    8 goto
        goto 语句是在源码级上跳转，容易破环程序结构。中庸之道：防止goto 的滥用
    9 switch

第五章 初始化与清理
    5.1 使用构造器确保初始化
        (1) 通过提供构造器，保证每个对象都可以被初始化。
        (2) 创建对象时，为对象分配内存空间，自动调用构造器，确保在操作对象之前就已经被初始化了
        (3) 不接受任何参数的构造器叫做 “默认构造器”
        (4) 构造器是一种特殊的类型方法，不返回任何值。这与返回值为空(void) 明显不同
    5.2 方法重载
        (1) 当创建一个对象时，也就给对象的存储空间去了一个名字。所谓的方法就是给某个动作取了一个名字
        (2) 每个重载的方法都有一个独一无二的参数类型列表（参数顺序不同也可以区分）
        (3) 基本类型可以从一个较小的类型自动转换为一个较大的类型。
            较小类型 通过类型的提升 转换为较大的类型 对于char 会直接提升为 int
            如果传入的类型大于参数需要的类型，会自动的进行行窄化处理
        (4) 通过返回值区分重载方法
    5.3 默认构造器
    5.4 this 关键字
        (1) 编译器 暗自把“所操作对象的引用” 作为第一个参数 传递个方法。this 就是当前对象的引用。
        (2) this 关键字对于把 当前对象传递给其他方法也很有用
        (3) 为了一个类写了多个构造器，有的时候需要在一个构造器调用另外一个构造器，为了避免重复代码，可以使用this 关键字
        (4) 了解this 关键字后，可以更好的理解 static 关键字。
            static 方法就是没有this 关键字的方法，内部不能调用非静态方法，反过来可以。即使没有创建对象，也可以通过类来调用静态方法。
    5.5 清理: 终结处理和垃圾回收
    5.6 成员初始化
        (1) 在类里定义一个对象引用时，如果没有初始化，会自动的获得一个特殊值 null
        (2) 指定初始化
        (3) 构造器初始化
    5.7 初始化顺序 先初始化静态对象，在初始化非晶态对象
    5.8 数组初始化
        (1) 可变参数列表
    5.9 enum 枚举类型
        (1) 和switch 搭配使用
        (2) 提供 toString() ordinal() 方法

第六章 访问控制权限
    6.1  包: 库单元 package
    6.2  public protected private 第一遍还没看懂，后面继续学习把
